# 面试 QA

本章包含 15 道核心面试题，覆盖 LightRAG 的架构设计、检索策略、存储系统、生产部署等方面。每道题都引用具体源码位置，帮助你深入理解实现细节。

---

## 架构设计（4 题）

### Q1: LightRAG 的四层存储分离设计有什么优势？为什么不用单一存储？

**难度**: ★★★★ | **类别**: 架构决策

LightRAG 将存储分为 KV、Vector、Graph、DocStatus 四层，每层有独立的抽象接口和多种实现。

请回答：
1. 四层分离的设计意图是什么？
2. 这种设计带来了哪些 trade-off？
3. 如果用单一存储（如 PostgreSQL）实现所有功能，会有什么问题？

**源码引用**:
- `lightrag/lightrag.py:554-650` (12 个存储实例创建)
- `lightrag/base.py:173-702` (存储抽象基类)
- `lightrag/kg/__init__.py:1-119` (存储注册表)

**参考答案要点**:
- **职责分离**：每种存储专注于特定数据类型（KV 存储文本、Vector 存储向量、Graph 存储关系）
- **灵活组合**：可以根据场景选择最适合的后端（如 KV 用 Redis、Vector 用 Milvus、Graph 用 Neo4j）
- **独立扩展**：某一层的性能瓶颈不影响其他层
- **Trade-off**：增加了系统复杂度、需要维护多个存储连接、数据一致性更难保证

---

### Q2: LightRAG 的初始化为什么分为三个阶段？为什么不在构造函数中完成所有初始化？

**难度**: ★★★★ | **类别**: 架构决策

LightRAG 的初始化分为 `__post_init__`、`initialize_storages()`、`check_and_migrate_data()` 三个阶段。

请回答：
1. 每个阶段分别做什么？
2. 为什么 `initialize_storages()` 必须手动调用？
3. 如果在构造函数中执行异步初始化会有什么问题？

**源码引用**:
- `lightrag/lightrag.py:444-668` (__post_init__)
- `lightrag/lightrag.py:670-708` (initialize_storages)
- `lightrag/lightrag.py:758-1057` (check_and_migrate_data)

**参考答案要点**:
- **Phase 1**：同步初始化（创建目录、验证配置、包装函数）
- **Phase 2**：异步初始化（数据库连接、文件锁、共享内存）
- **Phase 3**：数据迁移（版本升级、数据结构变更）
- **手动调用原因**：避免构造函数中的异步陷阱、明确生命周期控制、防止死锁

---

### Q3: LightRAG 使用 @dataclass 和 @final 装饰器的设计意图是什么？

**难度**: ★★★ | **类别**: 架构决策

LightRAG 类使用了 `@final` 和 `@dataclass` 两个装饰器。

请回答：
1. `@final` 装饰器的作用是什么？为什么禁止继承？
2. `@dataclass` 带来了哪些好处？
3. 如果需要扩展 LightRAG 的功能，应该怎么做？

**源码引用**:
- `lightrag/lightrag.py:128-443` (LightRAG 类定义)

**参考答案要点**:
- **@final**：禁止继承，鼓励组合而非继承，避免脆弱基类问题
- **@dataclass**：自动生成 `__init__`、类型安全、IDE 自动补全、配置即代码
- **扩展方式**：通过依赖注入（`llm_model_func`、`embedding_func`）、配置参数、存储后端切换

---

### Q4: LightRAG 与 GraphRAG（Microsoft）的核心区别是什么？

**难度**: ★★★★★ | **类别**: 框架对比

LightRAG 和 GraphRAG 都是知识图谱增强的 RAG 框架，但设计理念不同。

请回答：
1. 两者在图构建策略上有什么区别？
2. 两者在检索策略上有什么区别？
3. 在什么场景下应该选择 LightRAG？什么场景下选择 GraphRAG？

**源码引用**:
- `lightrag/operate.py:2766-2943` (实体提取)
- `lightrag/operate.py:3470-3520` (检索模式)

**参考答案要点**:
- **图构建**：LightRAG 直接提取实体-关系，GraphRAG 使用 Leiden 算法进行社区检测
- **检索策略**：LightRAG 有 5 种模式（local/global/hybrid/mix/naive），GraphRAG 主要依赖社区摘要
- **成本**：LightRAG LLM 调用少，GraphRAG 需要大量 LLM 调用构建社区摘要
- **适用场景**：LightRAG 适合中小规模、成本敏感；GraphRAG 适合大规模企业知识库

---

## 检索策略（4 题）

### Q5: LightRAG 的五种检索模式分别适合什么场景？

**难度**: ★★★★ | **类别**: 检索策略

LightRAG 提供 local、global、hybrid、mix、naive 五种检索模式。

请回答：
1. 每种模式的数据来源是什么？
2. 为什么推荐使用 mix 模式？
3. 什么情况下应该使用 naive 模式？

**源码引用**:
- `lightrag/operate.py:3470-3520` (_perform_kg_search)
- `lightrag/operate.py:4167-4217` (_get_node_data - local)
- `lightrag/operate.py:4440-4278` (_get_edge_data - global)

**参考答案要点**:
- **local**：实体向量检索 → 图谱扩展，适合特定实体查询
- **global**：关系向量检索 → 社区摘要，适合宏观主题查询
- **hybrid**：local + global 轮询合并，平衡查询
- **mix**：hybrid + 向量检索，最全面，推荐默认使用
- **naive**：纯向量检索，适合 KG 质量不高或简单问答场景

---

### Q6: LightRAG 的双层级关键词提取系统是如何工作的？

**难度**: ★★★ | **类别**: 检索策略

LightRAG 从查询中提取 high_level_keywords 和 low_level_keywords 两种关键词。

请回答：
1. 两种关键词分别用于什么目的？
2. 关键词提取的 Prompt 是如何设计的？
3. 如果关键词提取失败（返回空列表），系统如何处理？

**源码引用**:
- `lightrag/prompt.py:374-393` (keywords_extraction Prompt)
- `lightrag/operate.py:3013-3220` (kg_query 中的关键词处理)

**参考答案要点**:
- **high_level**：主题、概念、意图，用于 global 模式
- **low_level**：实体、专有名词、技术术语，用于 local 模式
- **Prompt 设计**：严格 JSON 格式、多词短语、边界情况处理
- **失败处理**：短查询（<50 字符）使用原文作为 low_level_keywords

---

### Q7: LightRAG 的 Token 预算控制系统是如何工作的？

**难度**: ★★★★ | **类别**: 检索策略

LightRAG 有精确的 Token 预算控制，避免 LLM 上下文溢出。

请回答：
1. Token 预算是如何分配的？
2. 截断策略是什么？
3. 为什么需要预留 LLM 响应空间？

**源码引用**:
- `lightrag/operate.py:3692-3721` (_apply_token_truncation)
- `lightrag/base.py:168-205` (QueryParam 中的 Token 参数)

**参考答案要点**:
- **预算分配**：实体 6000 + 关系 8000 + 块（剩余）+ LLM 响应预留 1500
- **截断策略**：按 Token 计数逐个添加，超过预算则停止
- **预留原因**：LLM 需要空间生成响应，避免输出被截断

---

### Q8: Reranker 在 LightRAG 中的作用是什么？为什么默认启用？

**难度**: ★★★ | **类别**: 检索策略

LightRAG 默认启用 Reranker 对检索结果进行二次排序。

请回答：
1. Reranker 和向量检索的区别是什么？
2. 为什么 mix 模式特别需要 Reranker？
3. 支持哪些 Reranker 模型？

**源码引用**:
- `lightrag/rerank.py` (Reranker 实现)
- `lightrag/operate.py:3950-3957` (process_chunks_unified 调用)

**参考答案要点**:
- **区别**：向量检索是"近似"匹配，Reranker 是"精确"相关性判断
- **mix 模式**：多来源数据（KG + 向量）需要统一排序
- **支持模型**：BAAI/bge-reranker-v2-m3、Jina rerankers

---

## 知识图谱（3 题）

### Q9: LightRAG 的实体提取 Prompt 有哪些关键设计？

**难度**: ★★★★ | **类别**: 知识图谱

LightRAG 使用精心设计的 Prompt 引导 LLM 提取实体和关系。

请回答：
1. 为什么使用固定字段数量和原子分隔符？
2. N-ary 关系分解的设计意图是什么？
3. Few-shot 示例是如何设计的？

**源码引用**:
- `lightrag/prompt.py:11-61` (entity_extraction_system_prompt)
- `lightrag/prompt.py:102-183` (Few-shot 示例)

**参考答案要点**:
- **固定字段**：消除解析歧义，易于验证
- **原子分隔符**：`<|#|>` 不可填充，避免内容中的特殊字符干扰
- **N-ary 分解**：图数据库天然支持二元关系，多元关系需要分解
- **Few-shot**：领域多样性（人物、金融、体育）、复杂度递增、格式严格

---

### Q10: LightRAG 的图合并算法是如何处理实体冲突的？

**难度**: ★★★★ | **类别**: 知识图谱

当多个文档提到同一个实体时，LightRAG 需要合并它们的信息。

请回答：
1. 实体合并的策略是什么？
2. 关系合并的策略是什么？
3. 删除文档时如何处理部分删除的实体？

**源码引用**:
- `lightrag/utils_graph.py` (merge_nodes_and_edges)
- `lightrag/lightrag.py:3282-3430` (删除时的实体重建)

**参考答案要点**:
- **实体合并**：描述用换行符连接，source_id 去重合并
- **关系合并**：方向规范化（无向图），关键词去重
- **部分删除**：调用 `rebuild_knowledge_from_chunks()` 从剩余 chunk 重建描述

---

### Q11: LightRAG 的 Multi-gleaning 策略是什么？为什么需要它？

**难度**: ★★★ | **类别**: 知识图谱

LightRAG 在实体提取时使用 Multi-gleaning 策略迭代补充遗漏实体。

请回答：
1. Multi-gleaning 的工作流程是什么？
2. 默认迭代次数是多少？为什么？
3. 如何判断是否需要继续迭代？

**源码引用**:
- `lightrag/operate.py:2814-2943` (_process_single_content)

**参考答案要点**:
- **工作流程**：初次提取 → 检查结果 → 补充提取 → 合并结果
- **默认次数**：1 次，平衡质量和成本
- **终止条件**：补充提取没有新实体时提前终止

---

## 存储与部署（4 题）

### Q12: LightRAG 的多租户隔离是如何实现的？

**难度**: ★★★★ | **类别**: 存储设计

LightRAG 通过 workspace 参数实现数据隔离。

请回答：
1. 不同存储后端的隔离策略有什么区别？
2. workspace 是如何传递到各个存储实例的？
3. 如果需要跨 workspace 查询，应该怎么做？

**源码引用**:
- `lightrag/lightrag.py:157` (workspace 字段)
- `lightrag/kg/json_kv_impl.py:28-39` (JSON 隔离)
- `lightrag/kg/neo4j_impl.py:67-95` (Neo4j 隔离)

**参考答案要点**:
- **JSON**：基于文件路径（子目录）
- **Neo4j**：基于 Label
- **PostgreSQL**：基于字段/前缀
- **跨 workspace**：需要创建多个 LightRAG 实例或自定义查询

---

### Q13: LightRAG 的 JWT 认证机制是如何工作的？

**难度**: ★★★ | **类别**: 生产部署

LightRAG API 支持 JWT 认证和 API Key 认证。

请回答：
1. 认证的优先级是什么？
2. Token 自动续期是如何实现的？
3. 哪些路径是白名单（不需要认证）？

**源码引用**:
- `lightrag/api/auth.py:23-107` (AuthHandler)
- `lightrag/api/utils_api.py:80-200` (combined_dependency)

**参考答案要点**:
- **优先级**：JWT Token > API Key > 白名单 > 无认证
- **自动续期**：剩余时间 < 阈值时，通过 `X-New-Token` 响应头返回新 Token
- **白名单**：`/health`、`/api/*`（Ollama 兼容 API）

---

### Q14: LightRAG 的 Gunicorn 多进程部署需要注意什么？

**难度**: ★★★★ | **类别**: 生产部署

LightRAG 支持 Gunicorn 多进程部署，但有一些注意事项。

请回答：
1. macOS 上多进程部署有什么限制？
2. 共享数据是如何在多进程间同步的？
3. 日志系统是如何处理多进程的？

**源码引用**:
- `lightrag/api/run_with_gunicorn.py:50-110` (macOS 检查)
- `lightrag/kg/shared_storage.py:137-257` (UnifiedLock)
- `lightrag/api/gunicorn_config.py:95-162` (生命周期钩子)

**参考答案要点**:
- **macOS 限制**：DOCLING + 多 Worker 不支持，需要设置 `OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES`
- **共享数据**：通过 `multiprocessing.Manager` 和 `UnifiedLock` 实现
- **日志**：每个 Worker 独立日志句柄，使用 RotatingFileHandler

---

### Q15: 如果让你重构 LightRAG，你会改什么？

**难度**: ★★★★★ | **类别**: 场景设计

这是一道开放性问题，考察你对项目的深度理解和系统设计能力。

请回答：
1. 你认为 LightRAG 的设计有哪些不足？
2. 如果要支持百万级文档，架构需要如何调整？
3. 如果要支持实时更新（文档变更后立即生效），需要做哪些改动？

**参考答案要点**:
- **不足**：单机架构、同步图合并、缺少分布式支持
- **百万级扩展**：分片存储、异步图合并、增量索引
- **实时更新**：事件驱动架构、增量实体提取、缓存失效策略

---

## 总结

这 15 道题覆盖了 LightRAG 的核心知识点：

| 类别 | 题数 | 核心考点 |
|------|------|----------|
| 架构设计 | 4 | 四层分离、三阶段初始化、装饰器设计、框架对比 |
| 检索策略 | 4 | 五种模式、关键词提取、Token 预算、Reranker |
| 知识图谱 | 3 | Prompt 设计、图合并、Multi-gleaning |
| 存储与部署 | 4 | 多租户、JWT 认证、Gunicorn、重构思考 |

**面试技巧**：
1. 回答时引用具体源码位置，展示你真正读过代码
2. 分析 trade-off，展示你的系统思维
3. 对比其他框架，展示你的行业认知
4. 提出改进建议，展示你的创造力
